# DeFi Integrations

With ZeroDev, you can swap tokens seamlessly on the same chain or across chains.  The tokens can either be "base tokens" or "DeFi tokens":

- **Base tokens** are normal tokens that do not represent a DeFi position.  Examples are ETH, USDC, etc. 
- **DeFi tokens** are ERC20 tokens that represent a DeFi position, such as in a [ERC-4626 vault](https://ethereum.org/en/developers/docs/standards/tokens/erc-4626/).  For example, depositing ETH into Lido gets you `stETH` that represents staked ETH.

By supporting both token types, ZeroDev exposes a highly powerful and flexible API that allows you to:

- Swap between any token pairs.
- Entering and exiting DeFi positions (staking, lending, etc.)

ZeroDev leverages [batching](/sdk/core-api/batch-transactions) and [delegatecall](/sdk/core-api/delegatecall) internally to ensure that even complex routes are executed in one atomic UserOp, providing the user with low latency, low gas cost, and high safety.

## Supported Tokens

See the full lists of supported base tokens and DeFi tokens:

- [Base tokens](/sdk/advanced/supported-base-tokens)
- [DeFi tokens (protocols)](/sdk/advanced/supported-defi-tokens)

## Installation

:::code-group

```bash [npm]
npm i @zerodev/defi
```

```bash [yarn]
yarn add @zerodev/defi
```

```bash [pnpm]
pnpm i @zerodev/defi
```

```bash [bun]
bun add @zerodev/defi
```

:::

## API 

:::info
Check out [these code examples](https://github.com/zerodevapp/zerodev-examples/tree/main/defi).
:::

### Creating a DeFi client

Start by creating a DeFi client:

```ts
import { createKernelDefiClient } from "@zerodev/defi"

const defiClient = createKernelDefiClient(kernelClient, projectId)
```

Where:

- `kernelClient` is the [account client](/sdk/core-api/create-account#create-an-account-client) object.
- `projectId` is your ZeroDev project ID, obtained from the dashboard.

### Swapping Tokens

Suppose you want to swap 100 USDC to USDT:

```ts
import { baseTokenAddresses } from "@zerodev/defi"
import { parseUnits } from "viem"
import { arbitrum } from "viem/chains"

// Replace this with your network
const chain = arbitrum

const userOpHash = await defiClient.sendSwapUserOp({
  tokenIn: baseTokenAddresses[chain.id].USDC,
  amountIn: parseUnits('100', 6),  // USDC uses 6 decimals
  tokenOut: baseTokenAddresses[chain.id].USDT,
  gasToken: 'sponsored',
})
```

Where:

- `tokenIn` is the input token.
- `amountIn` is a `bigint` representing the input token amount.  Note that this uses the smallest unit for the token, e.g. Wei for Ether.
- `tokenOut` is the output token.
- `gasToken`: specify how gas is paid for for this UserOp.  This can be:
  - `sponsored`: sponsor the UserOp.
  - `tokenIn`: pays gas in the input token, using a [ERC20 paymaster](/sdk/core-api/pay-gas-with-erc20s).
  - `tokenOut`: pays gas in the output token, using a [ERC20 paymaster](/sdk/core-api/pay-gas-with-erc20s).
  - `native`: pays gas in the native token, using the account's balance.
  - You can also specify an `Address` for a ERC20 token, to pay gas with that token using a [ERC20 paymaster](/sdk/core-api/pay-gas-with-erc20s).

### Entering / Exiting DeFi positions

Entering a DeFi position simply means swapping a token into a DeFi token.  For example, to enter the USDC AAV3 v3 lending vault:

```ts
const userOpHash = await defiClient.sendSwapUserOp({
  tokenIn: baseTokenAddresses[chain.id].USDC,
  amountIn: 1_000_000,
  tokenOut: defiTokenAddresses[chain.id]['USDC']['aave-v3'],
  gasToken: 'sponsored',
})
```

Similarly, exiting a DeFi position is just swapping a DeFi token into another token.

### Cross-chain Swaps

### Listing Tokens