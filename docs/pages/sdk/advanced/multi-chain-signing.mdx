# Multi-chain Signing

You can use Kernel with a "multi-chain validator" which can sign multiple UserOps in one signature, even if the UserOps are on different chains.  For example, if you want to bridge some assets from chain A, and then execute a transaction on chain B with the bridged assets, you can sign both the bridging transaction and the target transaction in a single signature.

## Examples

### Sending multi-chain transactions

If you want to send transactions across multiple chains with a single ecdsa signature, [refer to this code example.](https://github.com/zerodevapp/zerodev-examples/blob/main/multi-chain/main.ts)

If you want to use passkey instead of ecdsa, [refer to this code example.](https://github.com/zerodevapp/multi-chain-passkey-example)

### Creating multi-chain session keys

If you want to create multiple session keys across different chains, with a single signature, [refer to this code example](https://github.com/zerodevapp/zerodev-examples/blob/main/multi-chain/useSessionKeyWithApproval.ts).

If you want to use passkey instead of ecdsa, [refer to this code example.](https://github.com/zerodevapp/multi-chain-passkey-example/tree/session-key-with-serialization)


### Enabling plugins across chains

If you want to enable validators across chains (e.g. to enable recovery), with a single signature, [refer to this code example](https://github.com/zerodevapp/zerodev-examples/blob/main/multi-chain/sendUserOpsWithEnable.ts).

If you want to use passkey instead of ecdsa, [refer to this code example.](https://github.com/zerodevapp/multi-chain-passkey-example/tree/enable-regular)
