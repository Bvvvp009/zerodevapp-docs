# Getting Started with Permissions

In this tutorial, you will learn how to create composable permissions.

We will create what's commonly known as a "session key" -- a key that can only do specific things under specific conditions.  Here, we will create a key that can only mint an NFT, and can only mint once every month.

## Code Examples

Refer to these examples if you get lost in the tutorial:

- [Using permissions](https://github.com/zerodevapp/zerodev-examples/blob/main/permissions/main.ts)
- [Owner creates a session key](https://github.com/zerodevapp/zerodev-examples/blob/main/session-keys/owner-created.ts)
- [Register a session key with the owner](https://github.com/zerodevapp/zerodev-examples/blob/main/session-keys/agent-created.ts)

## Installation

The examples repo already installed this, but normally you would install permissions with:

:::code-group

```bash [npm]
npm i @zerodev/permissions
```

```bash [yarn]
yarn add @zerodev/permissions
```

```bash [pnpm]
pnpm i @zerodev/permissions
```

```bash [bun]
bun add @zerodev/permissions
```

:::

## API

:::info
You can reference this [complete code example](https://github.com/zerodevapp/zerodev-examples/blob/main/permissions/main.ts) as you go through the tutorial.
:::

With a permissions validator, you are putting together:

- One signer
- Any number of policies
- (optionally) one action

### Creating a signer

Start by creating a [ECDSA signer](/sdk/permissions/signers/ecdsa):

```ts
const sessionPrivateKey = generatePrivateKey()
const sessionKeyAccount = privateKeyToAccount(sessionPrivateKey)

const sessionKeySigner = await toECDSASigner({
  signer: sessionKeyAccount,
})
```

### Creating a number of policies

Now, let's create two policies:

- A "call policy" that checks that the user is minting an NFT.
- A "rate limit policy" that checks that the user executes this action once per month.

```ts
const sessionPrivateKey = generatePrivateKey()
const sessionKeyAccount = privateKeyToAccount(sessionPrivateKey)

const callPolicy = toCallPolicy({
  permissions: [
    {
      target: contractAddress,
      valueLimit: BigInt(0),
      abi: contractABI,
      functionName: "mint",
    },
  ],
})

const rateLimitPolicy = toRateLimitPolicy({
  count: 1,
  interval: 60 * 60 * 24 * 30,  // month in seconds
}),
```

### Composing signer and policies

Here comes the fun part -- we "compose" the signer and policies together into a single validator:

```ts
const sessionKeyValidator = await toPermissionValidator(publicClient, {
  entryPoint,
  signer: sessionKeySigner,
  policies: [
    callPolicy,
    rateLimitPolicy,
  ],
}),
```

Now, we have created a ECDSA session key that's subject to a call policy and a rate limit policy.  Just like that!

### Using the session key

Finally, we can set up the account with this session key as the signer.  Note that if this is the first time that the session key is used, we need to [enable the plugin](/sdk/core-api/using-plugins#enabling-a-regular-validator).

```ts
const account = await createKernelAccount(publicClient, {
  plugins: {
    sudo: ecdsaValidator,
    regular: sessionKeyValidator,
  },
  entryPoint,
})
```

Now you can [set up a Kernel client](/sdk/core-api/create-account#create-an-account-client) using this account, and start minting NFTs with this session key -- but only up to once a month!

Try running [this script](https://github.com/zerodevapp/zerodev-examples/blob/main/permissions/main.ts) and see for yourself.

## Storing Session Keys

Session keys (and permission validators in general) can be stored, by serializing them and then deserializing them later.

### Serializing a session key

```ts
const serializedSessionKey = await serializePermissionAccount(sessionKeyAccount, sessionPrivateKey)
```

Note that `sessionPrivateKey` is optional.  If the private key is not included, then you must provide the private key when you deserialize the session key.

### De-serializing a session key

```ts
const sessionKeySigner = await toECDSASigner({
  signer: privateKeyToAccount(sessionPrivateKey),
})

const sessionKeyAccount = await deserializePermissionAccount(
  publicClient,
  entryPoint,
  serializedSessionKey,
  sessionKeySigner,
)
```

Note that `sessionKeySigner` is only needed if you did not include the private key in the serialized session key.