# Getting Started with Permissions

In this tutorial, you will learn how to create composable permissions.

We will create what's commonly known as a "session key" -- a key that can only do specific things under specific conditions.  Here, we will create a key that can only mint an NFT, and can only mint once every month.

## Code Example

Clone and set up [the examples repo](https://github.com/zerodevapp/zerodev-examples) by following the README.

Make sure you can run the permissions example script with:

```ts
npx ts-node permissions/main.ts
```

Refer to the [example script](https://github.com/zerodevapp/zerodev-examples/blob/main/permissions/main.ts) as you follow this tutorial.

## Installation

The examples repo already installed this, but normally you would install permissions with:

:::code-group

```bash [npm]
npm i @zerodev/permissions
```

```bash [yarn]
yarn add @zerodev/permissions
```

```bash [pnpm]
pnpm i @zerodev/permissions
```

```bash [bun]
bun i @zerodev/permissions
```

:::

## API

:::info
You can reference this [complete code example](https://github.com/zerodevapp/zerodev-examples/blob/main/permissions/main.ts) as you go through the tutorial.
:::

With a permissions validator, you are putting together:

- One signer
- Any number of policies
- (optionally) one action

### Creating a signer

Start by creating a [ECDSA signer](/sdk/permissions/signers/ecdsa):

```ts
const sessionPrivateKey = generatePrivateKey()
const sessionKeyAccount = privateKeyToAccount(sessionPrivateKey)

const sessionKeySigner = await toECDSASigner({
  signer: sessionKeyAccount,
})
```

### Creating a number of policies

Now, let's create two policies:

- A "call policy" that checks that the user is minting an NFT.
- A "rate limit policy" that checks that the user executes this action once per month.

```ts
const sessionPrivateKey = generatePrivateKey()
const sessionKeyAccount = privateKeyToAccount(sessionPrivateKey)

const callPolicy = toCallPolicy({
  permissions: [
    {
      target: contractAddress,
      valueLimit: BigInt(0),
      abi: contractABI,
      functionName: "mint",
    },
  ],
})

const rateLimitPolicy = toRateLimitPolicy({
  count: 1,
  interval: 60 * 60 * 24 * 30,  // month in seconds
}),
```

### Composing signer and policies

Here comes the fun part -- we "compose" the signer and policies together into a single validator:

```ts
const sessionKeyValidator = await toPermissionValidator(publicClient, {
  entryPoint,
  signer: sessionKeySigner,
  policies: [
    callPolicy,
    rateLimitPolicy,
  ],
}),
```

Now, we have created a ECDSA session key that's subject to a call policy and a rate limit policy.  Just like that!

### Using the session key

Finally, we can set up the account with this session key as the signer.  Note that if this is the first time that the session key is used, we need to [enable the plugin](/sdk/core-api/using-plugins#enabling-a-regular-validator).

```ts
const account = await createKernelAccount(publicClient, {
  plugins: {
    sudo: ecdsaValidator,
    regular: sessionKeyValidator,
  },
  entryPoint,
})
```

Now you can [set up a Kernel client](/sdk/core-api/create-account#create-an-account-client) using this account, and start minting NFTs with this session key -- but only up to once a month!

Try running [this script](https://github.com/zerodevapp/zerodev-examples/blob/main/permissions/main.ts) and see for yourself.

## Storing Session Keys

Session keys (and permission validators in general) can be stored, by serializing them and then deserializing them later.

### Code examples

There are two general patterns with storing session keys.

- The owner creates a session key for another agent to store & use.  Check out [this example](https://github.com/zerodevapp/zerodev-examples/blob/main/session-keys/owner-created.ts).
- The agent creates a session key and asks the owner to "approve" it as a session key.  Check out [this example](https://github.com/zerodevapp/zerodev-examples/blob/main/session-keys/agent-created.ts).
  - In this flow, the owner never sees the private part of the session key, so it may be better for security.

### Serializing a session key

```ts
const serializedSessionKey = await serializePermissionAccount(sessionKeyAccount, sessionPrivateKey)
```

Note that `sessionPrivateKey` is optional.  If the private key is not included, then you must provide the private key when you deserialize the session key.

### De-serializing a session key

```ts
const sessionKeySigner = await toECDSASigner({
  signer: privateKeyToAccount(sessionPrivateKey),
})

const sessionKeyAccount = await deserializePermissionAccount(
  publicClient,
  entryPoint,
  serializedSessionKey,
  sessionKeySigner,
)
```

Note that `sessionKeySigner` is only needed if you did not include the private key in the serialized session key.
